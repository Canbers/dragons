/**
 * Migration: Extract embedded POIs from Settlement.locations[].pois[]
 * into standalone Poi collection documents.
 *
 * Usage:
 *   node db/migrations/migrate-pois-to-collection.js [up|down]
 *
 * Default is "up". Pass "down" to reverse.
 */

const mongoose = require('mongoose');

// Raw schemas â€” we don't use the Mongoose models here because
// Settlement.js no longer has the pois field in its schema.
// We work directly with the raw MongoDB driver.

const MONGO_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/dragons';

async function up() {
    console.log('[Migration UP] Extracting embedded POIs into Poi collection...');

    const db = mongoose.connection.db;
    const settlements = db.collection('settlements');
    const pois = db.collection('pois');

    const cursor = settlements.find({ 'locations.pois': { $exists: true, $ne: [] } });
    let totalExtracted = 0;
    let settlementsProcessed = 0;

    while (await cursor.hasNext()) {
        const settlement = await cursor.next();
        settlementsProcessed++;

        for (const location of (settlement.locations || [])) {
            if (!location.pois || location.pois.length === 0) continue;

            const docs = location.pois.map(poi => ({
                _id: poi._id, // Preserve original _id
                name: poi.name,
                type: poi.type || 'other',
                description: poi.description || '',
                icon: poi.icon || '',
                persistent: poi.persistent !== false,
                discovered: poi.discovered || false,
                interactionCount: poi.interactionCount || 0,
                lastInteraction: poi.lastInteraction || null,
                metadata: poi.metadata || {},
                settlement: settlement._id,
                locationId: location._id,
                locationName: location.name,
                autoGenerated: false,
                createdAt: new Date(),
                updatedAt: new Date()
            }));

            // Use ordered:false so duplicates (re-runs) don't stop the batch
            try {
                const result = await pois.insertMany(docs, { ordered: false });
                totalExtracted += result.insertedCount;
            } catch (e) {
                // Duplicate key errors are fine on re-run
                if (e.code === 11000 || e.writeErrors?.every(we => we.code === 11000)) {
                    const inserted = e.result?.nInserted || e.insertedCount || 0;
                    totalExtracted += inserted;
                    console.log(`  [Skip] ${location.name}: ${docs.length - inserted} already migrated`);
                } else {
                    throw e;
                }
            }
        }
    }

    console.log(`[Migration UP] Extracted ${totalExtracted} POIs from ${settlementsProcessed} settlements`);

    // Remove embedded pois arrays from settlements
    const unsetResult = await settlements.updateMany(
        {},
        { $unset: { 'locations.$[].pois': '' } }
    );
    console.log(`[Migration UP] Removed embedded pois from ${unsetResult.modifiedCount} settlements`);

    // Create indexes on the pois collection
    await pois.createIndex({ settlement: 1, locationId: 1 });
    await pois.createIndex({ settlement: 1, type: 1, name: 1 });
    await pois.createIndex({ settlement: 1, name: 1 });
    console.log('[Migration UP] Indexes created on pois collection');

    console.log('[Migration UP] Done!');
}

async function down() {
    console.log('[Migration DOWN] Moving Poi documents back into Settlement.locations[].pois[]...');

    const db = mongoose.connection.db;
    const settlements = db.collection('settlements');
    const pois = db.collection('pois');

    const cursor = pois.find({});
    const bySettlement = {};

    while (await cursor.hasNext()) {
        const poi = await cursor.next();
        const key = `${poi.settlement}_${poi.locationId}`;
        if (!bySettlement[key]) {
            bySettlement[key] = {
                settlementId: poi.settlement,
                locationId: poi.locationId,
                pois: []
            };
        }
        bySettlement[key].pois.push({
            _id: poi._id,
            name: poi.name,
            type: poi.type,
            description: poi.description,
            icon: poi.icon,
            persistent: poi.persistent,
            discovered: poi.discovered,
            interactionCount: poi.interactionCount,
            lastInteraction: poi.lastInteraction,
            metadata: poi.metadata
        });
    }

    let totalRestored = 0;
    for (const { settlementId, locationId, pois: poiList } of Object.values(bySettlement)) {
        await settlements.updateOne(
            { _id: settlementId, 'locations._id': locationId },
            { $set: { 'locations.$.pois': poiList } }
        );
        totalRestored += poiList.length;
    }

    console.log(`[Migration DOWN] Restored ${totalRestored} POIs to settlements`);

    // Drop the pois collection
    try {
        await pois.drop();
        console.log('[Migration DOWN] Dropped pois collection');
    } catch (e) {
        console.log('[Migration DOWN] pois collection already dropped');
    }

    console.log('[Migration DOWN] Done!');
}

async function main() {
    const direction = process.argv[2] || 'up';

    await mongoose.connect(MONGO_URI);
    console.log(`Connected to ${MONGO_URI}`);

    try {
        if (direction === 'down') {
            await down();
        } else {
            await up();
        }
    } finally {
        await mongoose.disconnect();
    }
}

main().catch(err => {
    console.error('Migration failed:', err);
    process.exit(1);
});
